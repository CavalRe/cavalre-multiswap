{
  "version": 3,
  "sources": ["../../../node_modules/@toruslabs/eccrypto/browser.js"],
  "sourcesContent": ["\"use strict\";\n\nvar EC = require(\"elliptic\").ec;\n\nvar ec = new EC(\"secp256k1\");\nvar browserCrypto = global.crypto || global.msCrypto || {};\nvar subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n\nvar nodeCrypto = require('crypto');\n\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst ZERO32 = Buffer.alloc(32, 0);\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey))\n  {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 && // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  var res = 0;\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];  // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  var arr = new Uint8Array(size);\n  if (typeof browserCrypto.getRandomValues === 'undefined') {\n    return Buffer.from(nodeCrypto.randomBytes(size));\n  } else {\n    browserCrypto.getRandomValues(arr);\n  }\n  return Buffer.from(arr);\n}\n\nfunction sha512(msg) {\n  return new Promise(function(resolve) {\n    var hash = nodeCrypto.createHash('sha512');\n    var result = hash.update(msg).digest();\n    resolve(new Uint8Array(result));\n  });\n}\n\nfunction getAes(op) {\n  return function(iv, key, data) {\n    return new Promise(function(resolve) {\n      if (subtle) {\n        var importAlgorithm = {name: \"AES-CBC\"};\n        var keyp = subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n        return keyp.then(function(cryptoKey) {\n          var encAlgorithm = {name: \"AES-CBC\", iv: iv};\n          return subtle[op](encAlgorithm, cryptoKey, data);\n        }).then(function(result) {\n          resolve(Buffer.from(new Uint8Array(result)));\n        });\n      } else {\n        if (op === 'encrypt') {\n          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);\n          let firstChunk = cipher.update(data);\n          let secondChunk = cipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n        else if (op === 'decrypt') {\n          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);\n          let firstChunk = decipher.update(data);\n          let secondChunk = decipher.final();\n          resolve(Buffer.concat([firstChunk, secondChunk]));\n        }\n      }\n    });\n  };\n}\n\nvar aesCbcEncrypt = getAes(\"encrypt\");\nvar aesCbcDecrypt = getAes(\"decrypt\");\n\nfunction hmacSha256Sign(key, msg) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var result = hmac.digest();\n    resolve(result);\n  });\n}\n\nfunction hmacSha256Verify(key, msg, sig) {\n  return new Promise(function(resolve) {\n    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));\n    hmac.update(msg);\n    var expectedSig = hmac.digest();\n    resolve(equalConstTime(expectedSig, sig));\n  });\n}\n\n/**\n  * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n  * depending on your browser.\n  * @return {Buffer} A 32-byte private key.\n  * @function\n  */\nexports.generatePrivate = function () {\n  var privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\n\nvar getPublic = exports.getPublic = function(privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"arr\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nvar getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  let compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"arr\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nexports.sign = function(privateKey, msg) {\n  return new Promise(function(resolve) {\n    assert(privateKey.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKey), \"Bad private key\");\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));\n  });\n};\n\nexports.verify = function(publicKey, msg, sig) {\n  return new Promise(function(resolve, reject) {\n    assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n    if (publicKey.length === 65)\n    {\n      assert(publicKey[0] === 4, \"Bad public key\");\n    }\n    if (publicKey.length === 33)\n    {\n      assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n    }\n    assert(msg.length > 0, \"Message should not be empty\");\n    assert(msg.length <= 32, \"Message is too long\");\n    if (ec.verify(msg, sig, publicKey)) {\n      resolve(null);\n    } else {\n      reject(new Error(\"Bad signature\"));\n    }\n  });\n};\n\nvar derive = exports.derive = function(privateKeyA, publicKeyB) {\n  return new Promise(function(resolve) {\n    assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n    assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n    assert(privateKeyA.length === 32, \"Bad private key\");\n    assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n    assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n    if (publicKeyB.length === 65)\n    {\n      assert(publicKeyB[0] === 4, \"Bad public key\");\n    }\n    if (publicKeyB.length === 33)\n    {\n      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n    }\n    var keyA = ec.keyFromPrivate(privateKeyA);\n    var keyB = ec.keyFromPublic(publicKeyB);\n    var Px = keyA.derive(keyB.getPublic());  // BN instance\n    resolve(Buffer.from(Px.toArray()));\n  });\n};\n\nexports.encrypt = function(publicKeyTo, msg, opts) {\n  opts = opts || {};\n  // Tmp variables to save context from flat promises;\n  var iv, ephemPublicKey, ciphertext, macKey;\n  return new Promise(function(resolve) {\n    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    // There is a very unlikely possibility that it is not a valid key\n    while(!isValidPrivateKey(ephemPrivateKey))\n    {\n      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n    }\n    ephemPublicKey = getPublic(ephemPrivateKey);\n    resolve(derive(ephemPrivateKey, publicKeyTo));\n  }).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    iv = opts.iv || randomBytes(16);\n    var encryptionKey = hash.slice(0, 32);\n    macKey = hash.slice(32);\n    return aesCbcEncrypt(iv, encryptionKey, msg);\n  }).then(function(data) {\n    ciphertext = data;\n    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n    return hmacSha256Sign(macKey, dataToMac);\n  }).then(function(mac) {\n    return {\n      iv: iv,\n      ephemPublicKey: ephemPublicKey,\n      ciphertext: ciphertext,\n      mac: mac,\n    };\n  });\n};\n\nexports.decrypt = function(privateKey, opts) {\n  // Tmp variable to save context from flat promises;\n  var encryptionKey;\n  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {\n    return sha512(Px);\n  }).then(function(hash) {\n    encryptionKey = hash.slice(0, 32);\n    var macKey = hash.slice(32);\n    var dataToMac = Buffer.concat([\n      opts.iv,\n      opts.ephemPublicKey,\n      opts.ciphertext\n    ]);\n    return hmacSha256Verify(macKey, dataToMac, opts.mac);\n  }).then(function(macGood) {\n    assert(macGood, \"Bad MAC\");\n    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);\n  }).then(function(msg) {\n    return Buffer.from(new Uint8Array(msg));\n  });\n};\n\n"],
  "mappings": "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",
  "names": []
}
